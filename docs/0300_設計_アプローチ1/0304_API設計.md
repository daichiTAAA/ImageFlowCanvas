# ImageFlowCanvas APIè¨­è¨ˆæ›¸

# æ–‡æ›¸ç®¡ç†æƒ…å ±

| é …ç›®       | å†…å®¹                      |
| ---------- | ------------------------- |
| æ–‡æ›¸å     | ImageFlowCanvas APIè¨­è¨ˆæ›¸ |
| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | 1.0                       |
| ä½œæˆæ—¥     | 2025å¹´7æœˆ12æ—¥             |
| æ›´æ–°æ—¥     | 2025å¹´7æœˆ12æ—¥             |


---

# 1. ãƒ—ãƒ­ãƒˆã‚³ãƒ«è¨­è¨ˆ

## 1.1. ãƒãƒƒãƒå‡¦ç†ï¼ˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œï¼‰ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant Client as ğŸ–¥ï¸ å¤–éƒ¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    participant Gateway as ğŸšª API Gateway
    participant API as ğŸ”§ Backend API
    participant gRPCServices as âš¡ gRPCå¸¸é§ã‚µãƒ¼ãƒ“ã‚¹
    participant MinIO as ğŸ’¾ MinIO
    participant Kafka as ğŸ“¨ Kafka
    participant WebUI as ğŸŒ Web UI

    Note over Client, WebUI: 1. ãƒãƒƒãƒå‡¦ç†è¦æ±‚
    Client->>Gateway: REST API<br/>POST /executions<br/>multipart/form-data<br/>ï¼ˆç”»åƒãƒ•ã‚¡ã‚¤ãƒ« + pipeline_idï¼‰
    Gateway->>API: HTTP/1.1è»¢é€
    API->>MinIO: ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ (S3 API)
    MinIO-->>API: file_idè¿”å´
    API-->>Client: execution_idå³åº§ã«è¿”å´
    
    Note over Client, WebUI: 2. ç›´æ¥gRPCå®Ÿè¡Œï¼ˆ40-100msï¼‰
    API->>gRPCServices: gRPCå‘¼ã³å‡ºã—<br/>ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
    gRPCServices->>MinIO: ç”»åƒå–å¾— (S3 API)
    gRPCServices->>gRPCServices: ç”»åƒå‡¦ç†å®Ÿè¡Œ<br/>ï¼ˆãƒªã‚µã‚¤ã‚ºâ†’AIæ¤œçŸ¥â†’ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
    gRPCServices->>MinIO: çµæœä¿å­˜ (S3 API)
    gRPCServices-->>API: å‡¦ç†å®Œäº†é€šçŸ¥ (40-100ms)
    
    Note over Client, WebUI: 3. é€²æ—é€šçŸ¥ï¼ˆç›£è¦–ç”¨ï¼‰
    gRPCServices->>Kafka: é€²æ—é€šçŸ¥<br/>Topic: pipeline-progress<br/>{<br/>  "execution_id": "exec-123",<br/>  "status": "completed",<br/>  "step_id": "resize-step-1"<br/>}
    
    Note over Client, WebUI: 4. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ UIæ›´æ–°
    API->>WebUI: WebSocketé€ä¿¡<br/>{<br/>  "type": "execution_update",<br/>  "execution_id": "exec-123",<br/>  "status": "completed"<br/>}
    
    Note over Client, WebUI: 5. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆå¤±æ•—æ™‚ã®ã¿ï¼‰
    API-->>Kafka: Kafkaãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯<br/>ï¼ˆç›´æ¥gRPCå¤±æ•—æ™‚ã®ã¿ï¼‰<br/>Topic: image-processing-requests
```
    
## 1.2. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ï¼ˆæ˜ åƒã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

### ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä½¿ã„åˆ†ã‘

æœ¬ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ç¨®é¡ã«å¿œã˜ã¦æœ€é©ãªé€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’é¸æŠã—ã¾ã™ï¼š

- **ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**: ãƒã‚¤ãƒ†ã‚£ãƒ–gRPCæ¥ç¶šã«ã‚ˆã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†ï¼ˆä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã€é«˜æ€§èƒ½ï¼‰
- **ğŸŒ Webãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ**: WebSocketæ¥ç¶šã«ã‚ˆã‚‹æ˜ åƒã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶åˆ¶ç´„å¯¾å¿œï¼‰

```mermaid
sequenceDiagram
    participant TauriApp as ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒª<br/>(ãƒã‚¤ãƒ†ã‚£ãƒ–)
    participant WebClient as ğŸŒ Webãƒ–ãƒ©ã‚¦ã‚¶<br/>(JavaScript)
    participant Gateway as ğŸšª API Gateway  
    participant StreamService as ğŸ¬ ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹
    participant AIService as ğŸ¤– AIæ¤œçŸ¥ã‚µãƒ¼ãƒ“ã‚¹
    participant Kafka as ğŸ“¨ Kafka

    Note over TauriApp, Kafka: 1. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆ¥ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼‰
    
    %% Tauri gRPCæ¥ç¶š
    TauriApp->>Gateway: gRPC Stream<br/>VideoFrame{<br/>  frame_data: bytes,<br/>  timestamp_ms: 1234567890,<br/>  metadata: {<br/>    source_id: "cam-001",<br/>    pipeline_id: "realtime-detect"<br/>  }<br/>}
    
    %% Web WebSocketæ¥ç¶š
    WebClient->>Gateway: WebSocket<br/>Binary Message<br/>{<br/>  type: "video_frame",<br/>  frame_data: base64,<br/>  timestamp_ms: 1234567890,<br/>  source_id: "cam-001",<br/>  pipeline_id: "realtime-detect"<br/>}
    
    Gateway->>StreamService: gRPCã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°è»¢é€<br/>ï¼ˆå†…éƒ¨çµ±ä¸€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼‰
    
    Note over TauriApp, Kafka: 2. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¨è«–ï¼ˆ<50msï¼‰
    StreamService->>AIService: gRPC Streamå‡¦ç†<br/>ï¼ˆãƒ¡ãƒ¢ãƒªãƒ™ãƒ¼ã‚¹ã€æ°¸ç¶šåŒ–ãªã—ï¼‰
    AIService->>AIService: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ AIæ¨è«–<br/>YOLO11ã«ã‚ˆã‚‹ç‰©ä½“æ¤œçŸ¥
    AIService-->>StreamService: ProcessedFrame{<br/>  processed_data: bytes,<br/>  detections: [...],<br/>  processing_time_ms: 35<br/>}
    
    Note over TauriApp, Kafka: 3. çµæœã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆ¥é…ä¿¡ï¼‰
    StreamService-->>Gateway: gRPC Streamè¿”å´
    
    %% Tauri gRPCé…ä¿¡
    Gateway-->>TauriApp: gRPC Stream<br/>ProcessedFrameè¿”å´
    
    %% Web WebSocketé…ä¿¡
    Gateway-->>WebClient: WebSocket<br/>JSON Message<br/>{<br/>  type: "processed_frame",<br/>  processed_data: base64,<br/>  detections: [...],<br/>  processing_time_ms: 35<br/>}
    
    Note over TauriApp, Kafka: 4. é¸æŠçš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    StreamService-->>Kafka: æ˜ åƒã‚¢ãƒ¼ã‚«ã‚¤ãƒ–<br/>Topic: video-stream-archive<br/>ï¼ˆé‡è¦ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã¿ï¼‰
    
    Note over TauriApp, Kafka: 5. ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°
    StreamService-->>TauriApp: gRPC Statusé€šçŸ¥
    StreamService-->>WebClient: WebSocketé€šçŸ¥<br/>{<br/>  "type": "stream_stats",<br/>  "fps": 30,<br/>  "latency_ms": 45<br/>}
```

### ãƒ—ãƒ­ãƒˆã‚³ãƒ«é¸æŠã®æŠ€è¡“çš„èƒŒæ™¯

| ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¨®åˆ¥  | é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ« | æŠ€è¡“çš„åˆ¶ç´„ãƒ»åˆ©ç‚¹                                                                                                                      |
| :---------------- | :------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
| **ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒª** | gRPC Stream    | â€¢ Rustãƒã‚¤ãƒ†ã‚£ãƒ–gRPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ<br/>â€¢ æœ€é«˜æ€§èƒ½ï¼ˆ<30msï¼‰<br/>â€¢ Protocol Buffersã«ã‚ˆã‚‹å‹å®‰å…¨æ€§<br/>â€¢ ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿åŠ¹ç‡è»¢é€            |
| **ğŸŒ Webãƒ–ãƒ©ã‚¦ã‚¶** | WebSocket      | â€¢ ãƒ–ãƒ©ã‚¦ã‚¶ã®gRPCåˆ¶ç´„å›é¿<br/>â€¢ gRPC-Web + Envoyã®è¤‡é›‘æ€§æ’é™¤<br/>â€¢ JSONãƒ™ãƒ¼ã‚¹ï¼ˆå¯èª­æ€§é‡è¦–ï¼‰<br/>â€¢ Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆäº’æ›æ€§é‡è¦–ï¼‰ |

## 1.3. ãƒ—ãƒ­ãƒˆã‚³ãƒ«æœ€é©åŒ–ã®é¸æŠåŸºæº–

| ğŸ¯ ç”¨é€”ãƒ»ã‚·ãƒŠãƒªã‚ª     | ğŸ–¥ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¨®åˆ¥ | ğŸš€ æ¨å¥¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«    | âš¡ æ€§èƒ½ç‰¹æ€§                                                       | ğŸ“ é¸æŠç†ç”±                               |
| :------------------- | :----------------- | :------------------ | :--------------------------------------------------------------- | :--------------------------------------- |
| ãƒãƒƒãƒç”»åƒå‡¦ç†       | Tauri/Webå…±é€š      | REST API + ç›´æ¥gRPC | â€¢ è¶…é«˜é€Ÿå‡¦ç† (40-100ms)<br/>â€¢ ãƒ•ã‚¡ã‚¤ãƒ«æ°¸ç¶šåŒ–<br/>â€¢ é«˜ä¿¡é ¼æ€§      | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã€çµæœä¿å­˜ãŒå¿…è¦ãªç”¨é€”   |
| ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒå‡¦ç† | ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒª      | gRPC Streaming      | â€¢ æ¥µä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚· (<30ms)<br/>â€¢ ãƒã‚¤ãƒ†ã‚£ãƒ–æ€§èƒ½<br/>â€¢ ãƒã‚¤ãƒŠãƒªåŠ¹ç‡ | ãƒ©ã‚¤ãƒ–é…ä¿¡ã€ç›£è¦–ã‚«ãƒ¡ãƒ©ã€æ¤œæŸ»ã‚·ã‚¹ãƒ†ãƒ ç”¨é€” |
| ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒå‡¦ç† | ğŸŒ Webãƒ–ãƒ©ã‚¦ã‚¶      | WebSocket           | â€¢ ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§<br/>â€¢ ä¸­ãƒ¬ã‚¤ãƒ†ãƒ³ã‚· (<100ms)<br/>â€¢ JSONå½¢å¼      | ãƒ–ãƒ©ã‚¦ã‚¶ãƒ™ãƒ¼ã‚¹ç›£è¦–ã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰       |
| é€²æ—é€šçŸ¥ãƒ»ç›£è¦–       | Tauri/Webå…±é€š      | Kafka + WebSocket   | â€¢ éåŒæœŸé€šçŸ¥<br/>â€¢ é«˜ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ<br/>â€¢ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§           | ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°         |
| ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†   | ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨       | Kafka Consumer      | â€¢ é«˜ä¿¡é ¼æ€§<br/>â€¢ é †åºä¿è¨¼<br/>â€¢ è€éšœå®³æ€§                         | ç›´æ¥gRPCå¤±æ•—æ™‚ã®ä»£æ›¿å‡¦ç†                 |
| UIæ›´æ–°é€šçŸ¥           | ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒª      | gRPC Push/WebSocket | â€¢ åŒæ–¹å‘é€šä¿¡<br/>â€¢ å‹å®‰å…¨<br/>â€¢ ä½ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰                 | Tauriã‚¢ãƒ—ãƒªå†…ã®é€²æ—è¡¨ç¤º                  |
| UIæ›´æ–°é€šçŸ¥           | ğŸŒ Webãƒ–ãƒ©ã‚¦ã‚¶      | WebSocket           | â€¢ åŒæ–¹å‘é€šä¿¡<br/>â€¢ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§<br/>â€¢ ãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–             | Webç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰                    |
| ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–         | ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨       | S3 API              | â€¢ RESTful<br/>â€¢ æ¨™æº–äº’æ›<br/>â€¢ é«˜å¯ç”¨æ€§                          | MinIOã¨ã®é€£æºã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸    |
| ã‚µãƒ¼ãƒ“ã‚¹é–“å†…éƒ¨é€šä¿¡   | ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨       | ç›´æ¥gRPC            | â€¢ å‹å®‰å…¨<br/>â€¢ è¶…é«˜æ€§èƒ½<br/>â€¢ Protocol Buffers                   | ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹å†…éƒ¨ã®é«˜é€Ÿé€šä¿¡           |

## 1.4. å‡¦ç†æ–¹å¼åˆ¥ãƒ—ãƒ­ãƒˆã‚³ãƒ«ä»•æ§˜

### 1.4.1. ğŸ“‹ ãƒãƒƒãƒå‡¦ç†ï¼ˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œï¼‰ä»•æ§˜

REST API multipart/form-dataã§ã®ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨ã€ç›´æ¥gRPCå®Ÿè¡Œã«ã‚ˆã‚‹40-100msé«˜é€Ÿå‡¦ç†ã‚’æä¾›ã€‚
å®Ÿè¡Œå®Œäº†å¾Œã€WebSocketã§é€²æ—é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã™ã€‚

### 1.4.2. ğŸ¬ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ï¼ˆæ˜ åƒã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰ä»•æ§˜

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¨®åˆ¥ã«å¿œã˜ãŸæœ€é©åŒ–ã•ã‚ŒãŸã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å®Ÿè£…ï¼š

**ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒªå‘ã‘ - gRPCã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°**
- ãƒ—ãƒ­ãƒˆã‚³ãƒ«: ãƒã‚¤ãƒ†ã‚£ãƒ–gRPC bidirectional streaming
- ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·: <30msï¼ˆæœ€é«˜æ€§èƒ½ï¼‰
- ãƒ‡ãƒ¼ã‚¿å½¢å¼: Protocol Buffersï¼ˆãƒã‚¤ãƒŠãƒªåŠ¹ç‡ï¼‰
- æ¥ç¶šæ–¹å¼: ç›´æ¥API Gatewayæ¥ç¶š

**ğŸŒ Webãƒ–ãƒ©ã‚¦ã‚¶å‘ã‘ - WebSocketã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°**
- ãƒ—ãƒ­ãƒˆã‚³ãƒ«: WebSocket binary/text messaging
- ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·: <100msï¼ˆãƒ–ãƒ©ã‚¦ã‚¶åˆ¶ç´„å†…ï¼‰
- ãƒ‡ãƒ¼ã‚¿å½¢å¼: JSON + Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼ˆäº’æ›æ€§é‡è¦–ï¼‰
- æ¥ç¶šæ–¹å¼: API GatewayçµŒç”±ã§ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«å¤‰æ›

### 1.4.3. ğŸ“¨ ç›£è¦–ãƒ»é€šçŸ¥ãƒ—ãƒ­ãƒˆã‚³ãƒ«ä»•æ§˜

Kafkaã«ã‚ˆã‚‹é€²æ—é€šçŸ¥ã¨WebSocketã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã§ã€
å®Ÿè¡ŒçŠ¶æ³ã®ç›£è¦–ã¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¡¨ç¤ºã‚’è¡Œã„ã¾ã™ã€‚

# 2. API ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

## 2.1. ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰APIã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 2.1.1. Backend APIè¨­è¨ˆæ€æƒ³

ImageFlowCanvasã®Backend APIã¯ã€**FastAPI + grpcio**ã«ã‚ˆã‚‹ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè£…ã‚’æ¡ç”¨ã—ã€è¤‡æ•°ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’çµ±åˆç®¡ç†ã™ã‚‹ã€Œå¸ä»¤å¡”ã€ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚

```python
# ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚µãƒ¼ãƒãƒ¼æ§‹æˆä¾‹
from fastapi import FastAPI
import grpc
from concurrent import futures
import asyncio

class HybridBackendAPI:
    def __init__(self):
        # FastAPI: REST + WebSocket
        self.fastapi_app = FastAPI()
        
        # gRPC Server: é«˜æ€§èƒ½å‡¦ç†
        self.grpc_server = grpc.server(futures.ThreadPoolExecutor())
        
        # å†…éƒ¨ã‚µãƒ¼ãƒ“ã‚¹æ¥ç¶šç®¡ç†
        self.grpc_clients = GRPCClientManager()
```

### 2.1.2. ãƒ—ãƒ­ãƒˆã‚³ãƒ«çµ±åˆæˆ¦ç•¥

| ãƒ—ãƒ­ãƒˆã‚³ãƒ«         | æ‹…å½“é ˜åŸŸ             | å®Ÿè£…æŠ€è¡“          | ç‰¹å¾´                               |
| ------------------ | -------------------- | ----------------- | ---------------------------------- |
| **FastAPI**        | REST API + WebSocket | uvicorn + asyncio | è‡ªå‹•ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆã€éåŒæœŸå‡¦ç†   |
| **grpcio**         | gRPCã‚µãƒ¼ãƒãƒ¼         | grpcio + asyncio  | é«˜æ€§èƒ½ã€å‹å®‰å…¨æ€§ã€Protocol Buffers |
| **WebSocket**      | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥     | FastAPI WebSocket | åŒæ–¹å‘é€šä¿¡ã€ç–çµåˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£   |
| **Kafka Consumer** | é€²æ—é…ä¿¡             | aiokafka          | éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ« |

## 2.2. RESTful APIè¨­è¨ˆ

### 2.2.1. åŸºæœ¬ä»•æ§˜
- ãƒ™ãƒ¼ã‚¹URL: `https://api.imageflowcanvas.com/v1`
- ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼šHTTPSå¿…é ˆ
- èªè¨¼ï¼šBearer Token (JWT)
- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ï¼š`application/json`
- ã‚¨ãƒ©ãƒ¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼šRFC 7807æº–æ‹ 

### 2.2.2. å®Ÿè£…æ¸ˆã¿ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¸€è¦§

| ã‚«ãƒ†ã‚´ãƒª         | ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ            | ãƒ¡ã‚½ãƒƒãƒ‰  | ç”¨é€”                 | å®Ÿè£…çŠ¶æ³ |
| ---------------- | ------------------------- | --------- | -------------------- | -------- |
| èªè¨¼             | `/auth/login`             | POST      | ãƒ­ã‚°ã‚¤ãƒ³             | âœ…        |
| èªè¨¼             | `/auth/logout`            | POST      | ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ           | âœ…        |
| ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯   | `/health`                 | GET       | ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª     | âœ…        |
| ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³     | `/pipelines`              | GET       | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä¸€è¦§     | âœ…        |
| ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³     | `/pipelines`              | POST      | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆ     | âœ…        |
| ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³     | `/pipelines/{id}`         | GET       | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³è©³ç´°     | âœ…        |
| ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³     | `/pipelines/{id}`         | PUT       | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ›´æ–°     | âœ…        |
| ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³     | `/pipelines/{id}`         | DELETE    | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‰Šé™¤     | âœ…        |
| å®Ÿè¡Œ             | `/executions`             | POST      | ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ     | âœ…        |
| å®Ÿè¡Œ             | `/executions/{id}`        | GET       | å®Ÿè¡ŒçŠ¶æ³å–å¾—         | âœ…        |
| å®Ÿè¡Œ             | `/executions/{id}/cancel` | POST      | å®Ÿè¡Œã‚­ãƒ£ãƒ³ã‚»ãƒ«       | âœ…        |
| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ   | `/components`             | GET       | ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¸€è¦§   | âœ…        |
| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ   | `/components/{id}`        | GET       | ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°   | âœ…        |
| ãƒ•ã‚¡ã‚¤ãƒ«         | `/files`                  | POST      | ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ | âœ…        |
| ãƒ•ã‚¡ã‚¤ãƒ«         | `/files/{id}`             | GET       | ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ | âœ…        |
| gRPCã‚µãƒ¼ãƒ“ã‚¹     | `/grpc-services`          | GET       | gRPCã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ³     | âœ…        |
| ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒ  | `/camera-stream`          | WebSocket | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒ     | âœ…        |

### 2.2.3. WebSocketå°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
- `/ws/execution/{execution_id}`: å®Ÿè¡Œé€²æ—é€šçŸ¥
- `/ws/system-status`: ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ³ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
- `/ws/camera-stream`: ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°

# 3. APIè©³ç´°ä»•æ§˜

## 3.1. ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡ŒAPIï¼ˆç›´æ¥gRPCå®Ÿè¡Œï¼‰

ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: `POST /v1/executions`

æ©Ÿèƒ½: ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†ã‚’å®Ÿè¡Œ

ãƒªã‚¯ã‚¨ã‚¹ãƒˆå½¢å¼: multipart/form-data
- pipeline_id (å¿…é ˆ): å®Ÿè¡Œã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®UUID
- input_files (å¿…é ˆ): å…¥åŠ›ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆè¤‡æ•°å¯¾å¿œï¼‰
- parameters (ã‚ªãƒ—ã‚·ãƒ§ãƒ³): å®Ÿè¡Œæ™‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆJSONå½¢å¼ï¼‰
- priority (ã‚ªãƒ—ã‚·ãƒ§ãƒ³): å„ªå…ˆåº¦ï¼ˆlow/normal/highï¼‰

ãƒ¬ã‚¹ãƒãƒ³ã‚¹:
- 202: å®Ÿè¡Œè¦æ±‚å—ä»˜ï¼ˆ40-100mså¾Œã«å®Œäº†äºˆå®šï¼‰
- 400: ç„¡åŠ¹ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ
- 500: ç›´æ¥gRPCå®Ÿè¡Œå¤±æ•—ï¼ˆKafkaãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰

## 3.2. å®Ÿè¡ŒçŠ¶æ³å–å¾—APIï¼ˆè¶…é«˜é€Ÿå®Œäº†å¯¾å¿œï¼‰

ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: `GET /v1/executions/{execution_id}`

æ©Ÿèƒ½: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã®çŠ¶æ³ã‚’å–å¾—

ãƒ¬ã‚¹ãƒãƒ³ã‚¹æƒ…å ±:
- execution_id: å®Ÿè¡ŒID
- status: å®Ÿè¡ŒçŠ¶æ³ï¼ˆpending/running/completed/failed/cancelledï¼‰
- execution_mode: å®Ÿè¡Œæ–¹å¼ï¼ˆdirect_grpc/kafka_fallbackï¼‰
- processing_time_ms: å®Ÿéš›ã®å‡¦ç†æ™‚é–“
- progress: é€²æ—æƒ…å ±
- steps: å„ã‚¹ãƒ†ãƒƒãƒ—ã®è©³ç´°çŠ¶æ³
- output_files: å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±

# 4. gRPC APIè¨­è¨ˆ

## 4.1. å®Ÿè£…æ¸ˆã¿gRPCã‚µãƒ¼ãƒ“ã‚¹

### 4.1.1. ã‚µãƒ¼ãƒ“ã‚¹æ§‹æˆ

ImageFlowCanvasã§ã¯ã€ä»¥ä¸‹ã®gRPCã‚µãƒ¼ãƒ“ã‚¹ãŒå®Ÿè£…ãƒ»ç¨¼åƒã—ã¦ã„ã¾ã™ï¼š

| ã‚µãƒ¼ãƒ“ã‚¹å              | ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ                 | æ©Ÿèƒ½                 | Protocol Buffers      |
| ----------------------- | ------------------------------ | -------------------- | --------------------- |
| **ResizeService**       | `resize-grpc-app:50051`        | ç”»åƒãƒªã‚µã‚¤ã‚ºå‡¦ç†     | `resize.proto`        |
| **AIDetectionService**  | `ai-detection-grpc-app:50052`  | AIç‰©ä½“æ¤œå‡ºãƒ»åˆ†é¡     | `ai_detection.proto`  |
| **FilterService**       | `filter-grpc-app:50053`        | ç”»åƒãƒ•ã‚£ãƒ«ã‚¿å‡¦ç†     | `filter.proto`        |
| **CameraStreamService** | `camera-stream-grpc-app:50054` | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒå‡¦ç† | `camera_stream.proto` |

### 4.1.2. å…±é€šãƒ—ãƒ­ãƒˆã‚³ãƒ«å®šç¾©ï¼ˆcommon.protoï¼‰

```protobuf
syntax = "proto3";
package imageflow.v1;

// å…±é€šç”»åƒãƒ‡ãƒ¼ã‚¿æ§‹é€ 
message ImageData {
  string bucket = 1;
  string object_key = 2;
  string content_type = 3;
  int64 size_bytes = 4;
  int32 width = 5;
  int32 height = 6;
  google.protobuf.Timestamp created_at = 7;
}

// ç›´æ¥ç”»åƒãƒã‚¤ãƒˆï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ç”¨ï¼‰
message ImageBytes {
  bytes data = 1;
  string format = 2;  // "JPEG", "PNG"
  int32 width = 3;
  int32 height = 4;
}

// å‡¦ç†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
enum ProcessingStatus {
  PROCESSING_STATUS_UNSPECIFIED = 0;
  PROCESSING_STATUS_PENDING = 1;
  PROCESSING_STATUS_RUNNING = 2;
  PROCESSING_STATUS_COMPLETED = 3;
  PROCESSING_STATUS_FAILED = 4;
}

// å‡¦ç†çµæœå…±é€šæ§‹é€ 
message ProcessingResult {
  ProcessingStatus status = 1;
  string message = 2;
  ImageData output_image = 3;
  bytes output_data = 7;  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ç”¨
  map<string, string> metadata = 4;
  google.protobuf.Timestamp processed_at = 5;
  double processing_time_seconds = 6;
}
```

## 4.2. å€‹åˆ¥ã‚µãƒ¼ãƒ“ã‚¹ä»•æ§˜

### 4.2.1. ResizeService (resize.proto)

**æ©Ÿèƒ½**: ç”»åƒãƒªã‚µã‚¤ã‚ºãƒ»å½¢å¼å¤‰æ›
**å‡¦ç†æ™‚é–“**: 10-20ms
**ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**: resize-grpc-app:50051

```protobuf
service ResizeService {
  rpc Resize(ResizeRequest) returns (ResizeResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message ResizeRequest {
  ImageData input_image = 1;
  int32 target_width = 2;
  int32 target_height = 3;
  string resize_mode = 4;  // "fit", "fill", "stretch"
  bool maintain_aspect_ratio = 5;
}

message ResizeResponse {
  ProcessingResult result = 1;
}
```

### 4.2.2. AIDetectionService (ai_detection.proto)

**æ©Ÿèƒ½**: AIç‰©ä½“æ¤œå‡ºãƒ»åˆ†é¡
**å‡¦ç†æ™‚é–“**: 20-50ms (GPUä½¿ç”¨æ™‚)
**ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**: ai-detection-grpc-app:50052

```protobuf
service AIDetectionService {
  rpc Detect(DetectionRequest) returns (DetectionResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message DetectionRequest {
  ImageData input_image = 1;
  string model_name = 2;      // "yolo11", "resnet50"
  float confidence_threshold = 3;
  repeated string target_classes = 4;
}

message DetectionResponse {
  ProcessingResult result = 1;
  repeated Detection detections = 2;
}

message Detection {
  string class_name = 1;
  float confidence = 2;
  BoundingBox bbox = 3;
}

message BoundingBox {
  float x = 1;
  float y = 2;
  float width = 3;
  float height = 4;
}
```

### 4.2.3. FilterService (filter.proto)

**æ©Ÿèƒ½**: ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ãƒ»å‰å¾Œå‡¦ç†
**å‡¦ç†æ™‚é–“**: 5-15ms
**ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**: filter-grpc-app:50053

```protobuf
service FilterService {
  rpc ApplyFilter(FilterRequest) returns (FilterResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message FilterRequest {
  ImageData input_image = 1;
  string filter_type = 2;    // "blur", "sharpen", "edge"
  map<string, string> parameters = 3;
}

message FilterResponse {
  ProcessingResult result = 1;
}
```

### 4.2.4. CameraStreamService (camera_stream.proto)

**æ©Ÿèƒ½**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†
**ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·**: <50ms
**ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**: camera-stream-grpc-app:50054

```protobuf
service CameraStreamService {
  rpc ProcessVideoStream(stream VideoFrame) returns (stream ProcessedFrame);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message VideoFrame {
  bytes frame_data = 1;
  int64 timestamp_ms = 2;
  map<string, string> metadata = 3;
}

message ProcessedFrame {
  bytes processed_data = 1;
  repeated Detection detections = 2;
  int64 processing_time_ms = 3;
  map<string, string> processing_stats = 4;
}
```

## 4.3. ã‚µãƒ¼ãƒ“ã‚¹æ¥ç¶šç®¡ç†

### 4.3.1. æ¥ç¶šè¨­å®š
```python
# gRPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®šä¾‹
GRPC_SERVICES = {
    "resize": {
        "address": "resize-grpc-app:50051",
        "timeout": 30,
        "retry_count": 3
    },
    "ai_detection": {
        "address": "ai-detection-grpc-app:50052", 
        "timeout": 60,
        "retry_count": 2
    },
    "filter": {
        "address": "filter-grpc-app:50053",
        "timeout": 20, 
        "retry_count": 3
    },
    "camera_stream": {
        "address": "camera-stream-grpc-app:50054",
        "timeout": 10,
        "retry_count": 1
    }
}
```

### 4.3.2. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ»å†—é•·æ€§
- **ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯é–“éš”**: 10ç§’
- **ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼**: å¤±æ•—é–¾å€¤5å›ã€å¾©æ—§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ30ç§’
- **Kafkaãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**: ç›´æ¥gRPCå¤±æ•—æ™‚ã®ä»£æ›¿å‡¦ç†
- **ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°**: ã‚µãƒ¼ãƒ“ã‚¹åˆ¥ã®è² è·åˆ†æ•£

# 5. WebSocket APIè¨­è¨ˆ

## 5.1. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€²æ—é€šçŸ¥

```javascript
// WebSocketæ¥ç¶šã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
ws://localhost:8080/ws/execution/{execution_id}

// é€²æ—é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼
{
  "type": "progress",
  "execution_id": "exec-uuid-123",
  "step": "ai_detection",
  "progress": 65.5,
  "status": "processing",
  "timestamp": "2025-07-21T10:30:01.085Z",
  "data": {
    "current_component": "AI Detection Service",
    "elapsed_time_ms": 1750,
    "estimated_remaining_ms": 850
  }
}

// å®Œäº†é€šçŸ¥
{
  "type": "completed",
  "execution_id": "exec-uuid-123",
  "total_time_ms": 87,
  "output_files": [
    {
      "file_id": "output-123",
      "filename": "result.jpg",
      "download_url": "/api/v1/files/output-123/download"
    }
  ]
}

// ã‚¨ãƒ©ãƒ¼é€šçŸ¥
{
  "type": "error",
  "execution_id": "exec-uuid-123",
  "error": {
    "code": "AI_SERVICE_UNAVAILABLE",
    "message": "AI Detection Service temporarily unavailable",
    "retry_after": 30
  }
}
```

# 6. æ¤œæŸ»æ©Ÿèƒ½APIè¨­è¨ˆ

## 6.1. Tauriæ¤œæŸ»ã‚¢ãƒ—ãƒªAPI

### 6.1.1. æ¤œæŸ»ãƒã‚¹ã‚¿ç®¡ç†API

**æ¤œæŸ»å¯¾è±¡ãƒã‚¹ã‚¿**
```http
GET /api/v1/inspection/targets
POST /api/v1/inspection/targets
GET /api/v1/inspection/targets/{target_id}
PUT /api/v1/inspection/targets/{target_id}
DELETE /api/v1/inspection/targets/{target_id}
```

**æ¤œæŸ»é …ç›®ãƒã‚¹ã‚¿**
```http
GET /api/v1/inspection/targets/{target_id}/items
POST /api/v1/inspection/targets/{target_id}/items
GET /api/v1/inspection/items/{item_id}
PUT /api/v1/inspection/items/{item_id}
DELETE /api/v1/inspection/items/{item_id}
```

### 6.1.2. æ¤œæŸ»å®Ÿè¡ŒAPI

**æ¤œæŸ»ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**
```http
POST /api/v1/inspection/sessions
GET /api/v1/inspection/sessions/{session_id}
PUT /api/v1/inspection/sessions/{session_id}
POST /api/v1/inspection/sessions/{session_id}/complete
```

**AIæ¤œæŸ»å®Ÿè¡Œï¼ˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³é€£æºï¼‰**
```http
POST /api/v1/inspection/sessions/{session_id}/ai-inspection
```

ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¾‹:
```json
{
  "session_id": "session-12345",
  "item_id": "item-67890",
  "image_file_path": "/path/to/captured/image.jpg",
  "pipeline_id": "pipeline-ai-detect-v1.2",
  "parameters": {
    "confidence_threshold": 0.8,
    "model_name": "yolo11"
  }
}
```

ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹:
```json
{
  "ai_result": {
    "overall_result": "NG",
    "confidence": 0.92,
    "detections": [
      {
        "class_name": "defect",
        "confidence": 0.92,
        "bbox": {"x": 150, "y": 200, "width": 50, "height": 30}
      }
    ]
  },
  "processing_time_ms": 1250,
  "pipeline_version": "v1.2",
  "created_at": "2025-07-27T10:30:00Z"
}
```

**äººã«ã‚ˆã‚‹æ¤œè¨¼API**
```http
POST /api/v1/inspection/sessions/{session_id}/human-verification
```

### 6.1.3. æ¤œæŸ»ãƒ‡ãƒ¼ã‚¿åŒæœŸAPI

**ã‚ªãƒ•ãƒ©ã‚¤ãƒ³åŒæœŸ**
```http
POST /api/v1/inspection/sync/upload
GET /api/v1/inspection/sync/download
```

**å·®åˆ†åŒæœŸ**
```http
GET /api/v1/inspection/sync/changes?since={timestamp}
POST /api/v1/inspection/sync/apply-changes
```

## 6.2. çµ±è¨ˆãƒ»ãƒ¬ãƒãƒ¼ãƒˆAPI

### 6.2.1. æ¤œæŸ»çµ±è¨ˆAPI

**åŸºæœ¬çµ±è¨ˆæƒ…å ±**
```http
GET /api/v1/inspection/statistics?start_date={date}&end_date={date}
```

ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹:
```json
{
  "summary": {
    "total_inspections": 1250,
    "ok_count": 1180,
    "ng_count": 70,
    "ok_rate": 94.4
  },
  "daily_trends": [
    {
      "date": "2025-07-27",
      "total": 85,
      "ok": 80,
      "ng": 5
    }
  ],
  "defect_analysis": {
    "scratch": 35,
    "contamination": 20,
    "deformation": 15
  }
}
```

### 6.2.2. å“è³ªãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨API

**ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å“è³ªæŒ‡æ¨™**
```http
GET /api/v1/inspection/quality/realtime
WebSocket: /ws/quality-metrics
```

**æ¤œæŸ»å‚¾å‘åˆ†æ**
```http
GET /api/v1/inspection/quality/trends
GET /api/v1/inspection/quality/alerts
```

## 6.3. ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çµ±åˆAPI

### 6.3.1. æ¤œæŸ»ç”¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç®¡ç†

**æ¤œæŸ»é …ç›®ã¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®é–¢é€£ä»˜ã‘**
```http
GET /api/v1/inspection/items/{item_id}/pipeline
PUT /api/v1/inspection/items/{item_id}/pipeline
```

**ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œçµæœã®æ¤œæŸ»çµæœã¸ã®å¤‰æ›**
```http
POST /api/v1/inspection/pipeline-results/convert
```

### 6.3.2. Tauriã‚¢ãƒ—ãƒªå°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

**ãƒ‡ãƒã‚¤ã‚¹ç™»éŒ²ãƒ»èªè¨¼**
```http
POST /api/v1/tauri/devices/register
POST /api/v1/tauri/auth/login
```

**ã‚¢ãƒ—ãƒªè¨­å®šåŒæœŸ**
```http
GET /api/v1/tauri/config
PUT /api/v1/tauri/config
```

## 6.4. WebSocket APIè¨­è¨ˆ

### 6.4.1. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€²æ—é€šçŸ¥

WebSocketæ¥ç¶šã«ã‚ˆã‚Šã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã®é€²æ—ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§é€šçŸ¥ã—ã¾ã™ã€‚

**æ¥ç¶šã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**
```
ws://localhost:8080/ws/execution/{execution_id}
ws://localhost:8080/ws/system-status
ws://localhost:8080/ws/camera-stream
ws://localhost:8080/ws/quality-metrics
```

**é€²æ—é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼**
```javascript
// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œé€²æ—
{
  "type": "progress",
  "execution_id": "exec-uuid-123",
  "step": "ai_detection",
  "progress": 65.5,
  "status": "processing",
  "timestamp": "2025-07-27T10:30:01.085Z",
  "data": {
    "current_component": "AI Detection Service",
    "elapsed_time_ms": 1750,
    "estimated_remaining_ms": 850
  }
}

// å®Œäº†é€šçŸ¥
{
  "type": "completed",
  "execution_id": "exec-uuid-123",
  "total_time_ms": 87,
  "output_files": [
    {
      "file_id": "output-123",
      "filename": "result.jpg",
      "download_url": "/api/v1/files/output-123/download"
    }
  ]
}

// ã‚¨ãƒ©ãƒ¼é€šçŸ¥
{
  "type": "error",
  "execution_id": "exec-uuid-123",
  "error": {
    "code": "AI_SERVICE_UNAVAILABLE",
    "message": "AI Detection Service temporarily unavailable",
    "retry_after": 30
  }
}
```

### 6.4.2. æ¤œæŸ»å“è³ªãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥

```javascript
// å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹æ›´æ–°
{
  "type": "quality_update",
  "timestamp": "2025-07-27T10:30:00Z",
  "metrics": {
    "hourly_ok_rate": 95.2,
    "current_ng_count": 3,
    "active_inspectors": 12
  }
}

// å“è³ªã‚¢ãƒ©ãƒ¼ãƒˆ
{
  "type": "quality_alert",
  "severity": "high",
  "message": "NG rate exceeded threshold (>5%)",
  "data": {
    "current_ng_rate": 7.2,
    "threshold": 5.0,
    "time_window": "last_hour"
  }
}
```

### 6.4.3. ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°æ˜ åƒé…ä¿¡

ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ˜ åƒå‡¦ç†ã®çµæœã‚’WebSocketã§é…ä¿¡ã—ã¾ã™ã€‚
- æ˜ åƒãƒ•ãƒ¬ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã®é…ä¿¡
- AIæ¤œå‡ºçµæœã®é€ä¿¡
- å‡¦ç†çµ±è¨ˆæƒ…å ±ã®é€šçŸ¥
- ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°åˆ¶å¾¡æ©Ÿèƒ½

## 6.5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä»•æ§˜

### 6.5.1. æ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ï¼ˆRFC 7807æº–æ‹ ï¼‰

```json
{
  "type": "https://api.imageflowcanvas.com/errors/validation-error",
  "title": "å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™",
  "status": 400,
  "detail": "confidence_thresholdã¯0.0-1.0ã®ç¯„å›²ã§æŒ‡å®šã—ã¦ãã ã•ã„",
  "instance": "/api/v1/inspection/sessions/session-123/ai-inspection",
  "validation_errors": [
    {
      "field": "confidence_threshold",
      "message": "å€¤ã¯0.0ä»¥ä¸Š1.0ä»¥ä¸‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™",
      "value": 1.5
    }
  ]
}
```

### 6.5.2. æ¤œæŸ»æ©Ÿèƒ½ç‰¹æœ‰ã®ã‚¨ãƒ©ãƒ¼

```json
{
  "type": "https://api.imageflowcanvas.com/errors/inspection-error",
  "title": "æ¤œæŸ»å®Ÿè¡Œã‚¨ãƒ©ãƒ¼",
  "status": 422,
  "detail": "æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒæ¤œæŸ»é …ç›®ã¨äº’æ›æ€§ãŒã‚ã‚Šã¾ã›ã‚“",
  "inspection_context": {
    "session_id": "session-123",
    "item_id": "item-456",
    "pipeline_id": "pipeline-789"
  }
}
```

# 7. Tauriã‹ã‚‰Backend APIã¸ã®gRPCé€šä¿¡

## 7.1. Tauri gRPC ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­è¨ˆ

Tauriã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰Backend APIã¸ã®é€šä¿¡ã¯ã€åŠ¹ç‡æ€§ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ã‚’é‡è¦–ã—ãŸgRPCãƒ™ãƒ¼ã‚¹ã®è¨­è¨ˆã‚’æ¡ç”¨ã—ã¾ã™ã€‚

### 7.1.1. é€šä¿¡ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```mermaid
sequenceDiagram
    participant TauriApp as ğŸ–¥ï¸ Tauriã‚¢ãƒ—ãƒª
    participant TauriBackend as ğŸ¦€ Tauri Backend (Rust)
    participant BackendAPI as ğŸ”§ Backend API (FastAPI)
    participant gRPCServices as âš¡ gRPCå¸¸é§ã‚µãƒ¼ãƒ“ã‚¹
    participant PostgreSQL as ğŸ—ƒï¸ PostgreSQL
    participant SQLite as ğŸ’¾ SQLite

    Note over TauriApp, SQLite: 1. åˆæœŸåŒ–ãƒ»èªè¨¼
    TauriApp->>TauriBackend: invoke("init_grpc_client")
    TauriBackend->>BackendAPI: gRPC: AuthService.Authenticate
    BackendAPI-->>TauriBackend: JWT Token
    TauriBackend-->>TauriApp: èªè¨¼æ¸ˆã¿çŠ¶æ…‹

    Note over TauriApp, SQLite: 2. ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿åŒæœŸ
    TauriApp->>TauriBackend: invoke("sync_master_data")
    TauriBackend->>BackendAPI: gRPC: SyncService.GetMasterData
    BackendAPI->>PostgreSQL: ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—
    PostgreSQL-->>BackendAPI: ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿
    BackendAPI-->>TauriBackend: gRPC Stream
    TauriBackend->>SQLite: ãƒ­ãƒ¼ã‚«ãƒ«åŒæœŸ
    TauriBackend-->>TauriApp: åŒæœŸå®Œäº†é€šçŸ¥

    Note over TauriApp, SQLite: 3. æ¤œæŸ»å®Ÿè¡Œ
    TauriApp->>TauriBackend: invoke("execute_inspection")
    TauriBackend->>BackendAPI: gRPC: InspectionService.Execute
    BackendAPI->>gRPCServices: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œå§”è­²
    gRPCServices-->>BackendAPI: å®Ÿè¡Œçµæœ
    BackendAPI-->>TauriBackend: gRPCçµæœã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°
    TauriBackend->>SQLite: çµæœä¿å­˜
    TauriBackend-->>TauriApp: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€²æ—æ›´æ–°
```

### 7.1.2. gRPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…ï¼ˆRustï¼‰

**Cargo.tomlä¾å­˜é–¢ä¿‚**:
```toml
[dependencies]
tonic = "0.8"
prost = "0.11"
tokio = { version = "1.0", features = ["full"] }
tokio-stream = "0.1"
serde = { version = "1.0", features = ["derive"] }
tauri = { version = "1.0", features = ["api-all"] }

[build-dependencies]
tonic-build = "0.8"
```

**gRPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…**:
```rust
use tonic::transport::Channel;
use tonic::Request;
use std::sync::Arc;
use tokio::sync::RwLock;

// è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸgRPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
use crate::proto::{
    auth_service_client::AuthServiceClient,
    sync_service_client::SyncServiceClient,
    inspection_service_client::InspectionServiceClient,
};

#[derive(Clone)]
pub struct TauriGrpcClient {
    channel: Channel,
    auth_client: Arc<RwLock<AuthServiceClient<Channel>>>,
    sync_client: Arc<RwLock<SyncServiceClient<Channel>>>,
    inspection_client: Arc<RwLock<InspectionServiceClient<Channel>>>,
    jwt_token: Arc<RwLock<Option<String>>>,
}

impl TauriGrpcClient {
    pub async fn new(endpoint: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let channel = Channel::from_static(endpoint).connect().await?;
        
        Ok(Self {
            channel: channel.clone(),
            auth_client: Arc::new(RwLock::new(AuthServiceClient::new(channel.clone()))),
            sync_client: Arc::new(RwLock::new(SyncServiceClient::new(channel.clone()))), 
            inspection_client: Arc::new(RwLock::new(InspectionServiceClient::new(channel.clone()))),
            jwt_token: Arc::new(RwLock::new(None)),
        })
    }

    pub async fn authenticate(&self, username: &str, password: &str) -> Result<String, Box<dyn std::error::Error>> {
        let mut client = self.auth_client.write().await;
        let request = Request::new(AuthRequest {
            username: username.to_string(),
            password: password.to_string(),
        });
        
        let response = client.authenticate(request).await?;
        let token = response.into_inner().token;
        
        *self.jwt_token.write().await = Some(token.clone());
        Ok(token)
    }

    pub async fn sync_master_data(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut client = self.sync_client.write().await;
        let token = self.jwt_token.read().await.clone()
            .ok_or("Not authenticated")?;
            
        let mut request = Request::new(SyncRequest {
            last_sync_timestamp: self.get_last_sync_timestamp().await?,
        });
        request.metadata_mut().insert("authorization", format!("Bearer {}", token).parse()?);
        
        let mut stream = client.get_master_data(request).await?.into_inner();
        
        while let Some(sync_data) = stream.message().await? {
            self.process_sync_data(sync_data).await?;
        }
        
        Ok(())
    }
}

// Tauriã‚³ãƒãƒ³ãƒ‰å®Ÿè£…
#[tauri::command]
pub async fn init_grpc_client(endpoint: String) -> Result<String, String> {
    let client = TauriGrpcClient::new(&endpoint).await
        .map_err(|e| e.to_string())?;
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã«ä¿å­˜
    Ok("gRPC client initialized".to_string())
}

#[tauri::command]
pub async fn sync_master_data() -> Result<String, String> {
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‹ã‚‰ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå–å¾—
    let client = get_global_client().await?;
    client.sync_master_data().await
        .map_err(|e| e.to_string())?;
    
    Ok("Master data synchronized".to_string())
}
```

### 7.1.3. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±åˆï¼ˆTypeScriptï¼‰

```typescript
import { invoke } from '@tauri-apps/api/tauri';

export class TauriApiClient {
    private initialized = false;

    async initialize(endpoint: string): Promise<void> {
        try {
            await invoke('init_grpc_client', { endpoint });
            this.initialized = true;
        } catch (error) {
            throw new Error(`gRPC client initialization failed: ${error}`);
        }
    }

    async syncMasterData(): Promise<void> {
        if (!this.initialized) {
            throw new Error('Client not initialized');
        }

        try {
            await invoke('sync_master_data');
        } catch (error) {
            throw new Error(`Master data sync failed: ${error}`);
        }
    }

    async executeInspection(pipelineId: string, imageData: ArrayBuffer): Promise<string> {
        if (!this.initialized) {
            throw new Error('Client not initialized');
        }

        try {
            const result = await invoke('execute_inspection', {
                pipelineId,
                imageData: Array.from(new Uint8Array(imageData))
            });
            return result as string;
        } catch (error) {
            throw new Error(`Inspection execution failed: ${error}`);
        }
    }
}
```

# 8. Backend APIã§ã®å®šç¾©æ¸ˆã¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Ÿè¡Œ

## 8.1. ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³è¨­è¨ˆ

Backend APIã¯ã€äº‹å‰ã«å®šç¾©ã•ã‚ŒãŸãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’åŠ¹ç‡çš„ã«å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚

### 8.1.1. ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œãƒ•ãƒ­ãƒ¼

```mermaid
flowchart TD
    A[ğŸ“‹ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œè¦æ±‚] --> B[ğŸ” ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®šç¾©å–å¾—]
    B --> C[âœ… å®Ÿè¡Œå‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³]
    C --> D{ğŸ¤” å®Ÿè¡Œæ–¹å¼é¸æŠ}
    
    D -->|é«˜é€Ÿå‡¦ç†| E[âš¡ ç›´æ¥gRPCå®Ÿè¡Œ]
    D -->|è² è·åˆ†æ•£| F[ğŸ“¨ Kafka Queue]
    
    E --> G[ğŸ”§ gRPCã‚µãƒ¼ãƒ“ã‚¹å‘¼å‡º]
    F --> H[âš–ï¸ Worker Pool]
    H --> G
    
    G --> I[ğŸ“Š å®Ÿè¡Œçµæœåé›†]
    I --> J[ğŸ’¾ çµæœä¿å­˜]
    J --> K[ğŸ“¡ é€šçŸ¥é…ä¿¡]
    K --> L[âœ… å®Ÿè¡Œå®Œäº†]
    
    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000
    style B fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    style C fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
    style D fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
    style E fill:#e1f5fe,stroke:#0277bd,stroke-width:3px,color:#000
    style F fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
    style G fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    style H fill:#ffebee,stroke:#c62828,stroke-width:2px,color:#000
    style I fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
    style J fill:#f1f8e9,stroke:#689f38,stroke-width:2px,color:#000
    style K fill:#e0f2f1,stroke:#00695c,stroke-width:2px,color:#000
    style L fill:#e8f5e8,stroke:#4caf50,stroke-width:3px,color:#000
```

### 8.1.2. ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®šç¾©ç®¡ç†

**ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®šç¾©ã‚¹ã‚­ãƒ¼ãƒ**:
```json
{
  "pipeline_id": "quality-inspection-v1",
  "name": "å“è³ªæ¤œæŸ»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³",
  "version": "1.0.0",
  "description": "AI ã«ã‚ˆã‚‹æ¬ é™¥æ¤œå‡ºã¨å“è³ªè©•ä¾¡",
  "execution_mode": "direct_grpc", 
  "steps": [
    {
      "step_id": "resize",
      "service": "ResizeService",
      "method": "Resize",
      "input_schema": {
        "width": "integer",
        "height": "integer", 
        "maintain_aspect_ratio": "boolean"
      },
      "timeout_ms": 5000,
      "retry_count": 3
    },
    {
      "step_id": "ai_detection",
      "service": "AIDetectionService", 
      "method": "DetectDefects",
      "depends_on": ["resize"],
      "input_schema": {
        "model_name": "string",
        "confidence_threshold": "float"
      },
      "timeout_ms": 30000,
      "retry_count": 2
    },
    {
      "step_id": "quality_filter",
      "service": "FilterService",
      "method": "ApplyQualityFilter", 
      "depends_on": ["ai_detection"],
      "input_schema": {
        "filter_type": "enum",
        "parameters": "object"
      },
      "timeout_ms": 10000,
      "retry_count": 3
    }
  ],
  "error_handling": {
    "strategy": "fail_fast",
    "rollback_enabled": true,
    "notification_on_failure": true
  }
}
```

### 8.1.3. å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…ï¼ˆPython FastAPIï¼‰

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import asyncio
import json
import grpc
from concurrent.futures import ThreadPoolExecutor

class ExecutionMode(Enum):
    DIRECT_GRPC = "direct_grpc"
    KAFKA_QUEUE = "kafka_queue"
    HYBRID = "hybrid"

@dataclass
class PipelineStep:
    step_id: str
    service: str
    method: str
    input_schema: Dict[str, Any]
    depends_on: List[str]
    timeout_ms: int
    retry_count: int

@dataclass 
class PipelineDefinition:
    pipeline_id: str
    name: str
    version: str
    execution_mode: ExecutionMode
    steps: List[PipelineStep]
    error_handling: Dict[str, Any]

class PipelineExecutor:
    def __init__(self):
        self.grpc_clients = {}
        self.executor = ThreadPoolExecutor(max_workers=10)
        
    async def execute_pipeline(
        self, 
        pipeline_id: str, 
        input_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """äº‹å‰å®šç¾©ã•ã‚ŒãŸãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å®Ÿè¡Œ"""
        
        # 1. ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®šç¾©å–å¾—
        pipeline_def = await self.get_pipeline_definition(pipeline_id)
        
        # 2. å®Ÿè¡Œå‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        await self.validate_execution_context(pipeline_def, input_data)
        
        # 3. å®Ÿè¡Œæ–¹å¼ã«å¿œã˜ãŸå‡¦ç†
        if pipeline_def.execution_mode == ExecutionMode.DIRECT_GRPC:
            return await self.execute_direct_grpc(pipeline_def, input_data)
        elif pipeline_def.execution_mode == ExecutionMode.KAFKA_QUEUE:
            return await self.execute_via_kafka(pipeline_def, input_data)
        else:
            return await self.execute_hybrid(pipeline_def, input_data)
    
    async def execute_direct_grpc(
        self, 
        pipeline_def: PipelineDefinition, 
        input_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ç›´æ¥gRPCå®Ÿè¡Œï¼ˆ40-100msé«˜é€Ÿå‡¦ç†ï¼‰"""
        
        execution_context = {
            "pipeline_id": pipeline_def.pipeline_id,
            "execution_id": self.generate_execution_id(),
            "start_time": asyncio.get_event_loop().time(),
            "step_results": {}
        }
        
        try:
            # ä¾å­˜é–¢ä¿‚ã«åŸºã¥ãã‚¹ãƒ†ãƒƒãƒ—é †åºæ±ºå®š
            execution_order = self.resolve_dependencies(pipeline_def.steps)
            
            # å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’é †æ¬¡å®Ÿè¡Œ
            for step in execution_order:
                step_input = self.prepare_step_input(
                    step, input_data, execution_context["step_results"]
                )
                
                # gRPCã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—
                step_result = await self.call_grpc_service(
                    step.service, step.method, step_input, step.timeout_ms
                )
                
                execution_context["step_results"][step.step_id] = step_result
                
                # é€²æ—é€šçŸ¥
                await self.notify_progress(
                    execution_context["execution_id"], 
                    step.step_id, 
                    "completed"
                )
            
            # å®Ÿè¡Œå®Œäº†
            execution_context["status"] = "completed"
            execution_context["end_time"] = asyncio.get_event_loop().time()
            
            return {
                "execution_id": execution_context["execution_id"],
                "status": "completed",
                "results": execution_context["step_results"],
                "execution_time_ms": int(
                    (execution_context["end_time"] - execution_context["start_time"]) * 1000
                )
            }
            
        except Exception as e:
            await self.handle_execution_error(execution_context, e)
            raise
    
    async def call_grpc_service(
        self, 
        service_name: str, 
        method_name: str, 
        input_data: Dict[str, Any],
        timeout_ms: int
    ) -> Dict[str, Any]:
        """gRPCã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—"""
        
        client = self.grpc_clients.get(service_name)
        if not client:
            raise ValueError(f"gRPC client not found for service: {service_name}")
        
        try:
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã§gRPCå‘¼ã³å‡ºã—
            async with asyncio.timeout(timeout_ms / 1000):
                method = getattr(client, method_name)
                response = await method(input_data)
                return response
                
        except asyncio.TimeoutError:
            raise Exception(f"gRPC call timeout: {service_name}.{method_name}")
        except grpc.RpcError as e:
            raise Exception(f"gRPC error: {e.details()}")

# FastAPI ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…
@app.post("/api/v1/pipelines/{pipeline_id}/execute")
async def execute_predefined_pipeline(
    pipeline_id: str,
    request: PipelineExecutionRequest
):
    """å®šç¾©æ¸ˆã¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡ŒAPI"""
    
    executor = PipelineExecutor()
    
    try:
        result = await executor.execute_pipeline(
            pipeline_id=pipeline_id,
            input_data=request.input_data
        )
        
        return {
            "success": True,
            "execution_id": result["execution_id"],
            "status": result["status"],
            "results": result["results"],
            "execution_time_ms": result["execution_time_ms"]
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": {
                "type": "pipeline_execution_error",
                "message": str(e),
                "pipeline_id": pipeline_id
            }
        }
```

# 9. å®šç¾©æ¸ˆã¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã®å¸¸é§gRPCã‚µãƒ¼ãƒ“ã‚¹ã®ä½¿ç”¨

## 9.1. å¸¸é§gRPCã‚µãƒ¼ãƒ“ã‚¹ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

å®šç¾©æ¸ˆã¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¯ã€é«˜æ€§èƒ½å‡¦ç†ã®ãŸã‚ã«å¸¸é§gRPCã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ¼ãƒ«ã‚’æ´»ç”¨ã—ã¾ã™ã€‚

### 9.1.1. ã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ¼ãƒ«ç®¡ç†

```mermaid
graph TB
    subgraph "ğŸ—ï¸ Service Pool Manager"
        SPM[Service Pool Manager]
        HC[Health Checker]
        LB[Load Balancer]
        RM[Resource Monitor]
    end
    
    subgraph "âš¡ Resident gRPC Services"
        RS1[ResizeService #1<br/>Status: Active<br/>Load: 20%]
        RS2[ResizeService #2<br/>Status: Active<br/>Load: 45%]
        AI1[AIDetectionService #1<br/>Status: Active<br/>Load: 80%]
        AI2[AIDetectionService #2<br/>Status: Active<br/>Load: 60%]
        FS1[FilterService #1<br/>Status: Active<br/>Load: 15%]
    end
    
    subgraph "ğŸ“‹ Pipeline Executor"
        PE[Pipeline Executor]
        SD[Service Discovery]
        RC[Retry Controller]
    end
    
    SPM --> RS1 & RS2 & AI1 & AI2 & FS1
    HC --> RS1 & RS2 & AI1 & AI2 & FS1
    LB --> RS1 & RS2 & AI1 & AI2 & FS1
    RM --> RS1 & RS2 & AI1 & AI2 & FS1
    
    PE --> SD
    SD --> LB
    RC --> LB
    
    style SPM fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#000
    style HC fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    style LB fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
    style RM fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
    style RS1 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px,color:#000
    style RS2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px,color:#000
    style AI1 fill:#ffebee,stroke:#e53935,stroke-width:2px,color:#000
    style AI2 fill:#fff4e8,stroke:#ff9800,stroke-width:2px,color:#000
    style FS1 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px,color:#000
    style PE fill:#e1f5fe,stroke:#0277bd,stroke-width:2px,color:#000
    style SD fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    style RC fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
```

### 9.1.2. ã‚µãƒ¼ãƒ“ã‚¹ç™ºè¦‹ãƒ»è² è·åˆ†æ•£

**Service Registryå®Ÿè£…**:
```python
import asyncio
from typing import Dict, List, Optional
from dataclasses import dataclass, field
from enum import Enum
import random
import time

class ServiceStatus(Enum):
    ACTIVE = "active"
    BUSY = "busy" 
    UNAVAILABLE = "unavailable"
    MAINTENANCE = "maintenance"

@dataclass
class ServiceInstance:
    service_name: str
    instance_id: str
    endpoint: str
    status: ServiceStatus
    current_connections: int = 0
    max_connections: int = 100
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    last_health_check: float = field(default_factory=time.time)
    response_time_ms: float = 0.0

class ServiceRegistry:
    def __init__(self):
        self.services: Dict[str, List[ServiceInstance]] = {}
        self.health_check_interval = 30  # 30ç§’
        self.running = False
        
    async def register_service(self, instance: ServiceInstance):
        """ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç™»éŒ²"""
        if instance.service_name not in self.services:
            self.services[instance.service_name] = []
        self.services[instance.service_name].append(instance)
        
    async def discover_service(
        self, 
        service_name: str, 
        load_balancing: str = "least_connections"
    ) -> Optional[ServiceInstance]:
        """ã‚µãƒ¼ãƒ“ã‚¹ç™ºè¦‹ãƒ»è² è·åˆ†æ•£"""
        
        if service_name not in self.services:
            return None
            
        available_instances = [
            instance for instance in self.services[service_name]
            if instance.status == ServiceStatus.ACTIVE
        ]
        
        if not available_instances:
            return None
            
        # è² è·åˆ†æ•£ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é©ç”¨
        if load_balancing == "least_connections":
            return min(available_instances, key=lambda x: x.current_connections)
        elif load_balancing == "response_time":
            return min(available_instances, key=lambda x: x.response_time_ms)
        elif load_balancing == "cpu_usage":
            return min(available_instances, key=lambda x: x.cpu_usage)
        else:  # random
            return random.choice(available_instances)
    
    async def start_health_monitoring(self):
        """ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯é–‹å§‹"""
        self.running = True
        while self.running:
            await self.perform_health_checks()
            await asyncio.sleep(self.health_check_interval)
    
    async def perform_health_checks(self):
        """å…¨ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
        for service_name, instances in self.services.items():
            for instance in instances:
                try:
                    # gRPCãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
                    health_response = await self.check_instance_health(instance)
                    
                    if health_response["healthy"]:
                        instance.status = ServiceStatus.ACTIVE
                        instance.cpu_usage = health_response["cpu_usage"]
                        instance.memory_usage = health_response["memory_usage"]
                        instance.current_connections = health_response["connections"]
                        instance.response_time_ms = health_response["response_time_ms"]
                    else:
                        instance.status = ServiceStatus.UNAVAILABLE
                        
                    instance.last_health_check = time.time()
                    
                except Exception as e:
                    instance.status = ServiceStatus.UNAVAILABLE
                    print(f"Health check failed for {instance.instance_id}: {e}")

class PipelineGrpcClient:
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
        self.grpc_connections = {}
        
    async def execute_step(
        self, 
        service_name: str, 
        method_name: str, 
        input_data: Dict[str, Any],
        timeout_ms: int = 30000,
        max_retries: int = 3
    ) -> Dict[str, Any]:
        """ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œï¼ˆè‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ä»˜ãï¼‰"""
        
        last_error = None
        
        for attempt in range(max_retries + 1):
            try:
                # ã‚µãƒ¼ãƒ“ã‚¹ç™ºè¦‹
                instance = await self.service_registry.discover_service(
                    service_name, "least_connections"
                )
                
                if not instance:
                    raise Exception(f"No available instance for service: {service_name}")
                
                # gRPCæ¥ç¶šå–å¾—/ä½œæˆ
                client = await self.get_grpc_client(instance)
                
                # æ¥ç¶šæ•°ã‚«ã‚¦ãƒ³ãƒˆå¢—åŠ 
                instance.current_connections += 1
                
                try:
                    # ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè¡Œ
                    start_time = time.time()
                    method = getattr(client, method_name)
                    
                    async with asyncio.timeout(timeout_ms / 1000):
                        result = await method(input_data)
                    
                    # ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“æ›´æ–°
                    instance.response_time_ms = (time.time() - start_time) * 1000
                    
                    return result
                    
                finally:
                    # æ¥ç¶šæ•°ã‚«ã‚¦ãƒ³ãƒˆæ¸›å°‘
                    instance.current_connections = max(0, instance.current_connections - 1)
                    
            except Exception as e:
                last_error = e
                if attempt < max_retries:
                    # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§ãƒªãƒˆãƒ©ã‚¤
                    wait_time = (2 ** attempt) * 0.1
                    await asyncio.sleep(wait_time)
                    continue
                else:
                    break
        
        raise Exception(f"gRPC call failed after {max_retries + 1} attempts: {last_error}")
    
    async def get_grpc_client(self, instance: ServiceInstance):
        """gRPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå–å¾—ï¼ˆã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«ï¼‰"""
        
        if instance.endpoint not in self.grpc_connections:
            # æ–°ã—ã„æ¥ç¶šã‚’ä½œæˆ
            channel = grpc.aio.insecure_channel(instance.endpoint)
            
            # ã‚µãƒ¼ãƒ“ã‚¹åã«å¿œã˜ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä½œæˆ
            if instance.service_name == "ResizeService":
                from .proto.resize_pb2_grpc import ResizeServiceStub
                client = ResizeServiceStub(channel)
            elif instance.service_name == "AIDetectionService":
                from .proto.ai_detection_pb2_grpc import AIDetectionServiceStub
                client = AIDetectionServiceStub(channel)
            elif instance.service_name == "FilterService":
                from .proto.filter_pb2_grpc import FilterServiceStub
                client = FilterServiceStub(channel)
            else:
                raise ValueError(f"Unknown service: {instance.service_name}")
                
            self.grpc_connections[instance.endpoint] = client
        
        return self.grpc_connections[instance.endpoint]

# çµ±åˆä¾‹ï¼šãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã§ã®ä½¿ç”¨
class EnhancedPipelineExecutor:
    def __init__(self):
        self.service_registry = ServiceRegistry()
        self.grpc_client = PipelineGrpcClient(self.service_registry)
        
    async def initialize(self):
        """å¸¸é§ã‚µãƒ¼ãƒ“ã‚¹ç™ºè¦‹ãƒ»ç™»éŒ²"""
        
        # åˆ©ç”¨å¯èƒ½ãªã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç™ºè¦‹ãƒ»ç™»éŒ²
        resize_instances = [
            ServiceInstance("ResizeService", "resize-1", "localhost:50051", ServiceStatus.ACTIVE),
            ServiceInstance("ResizeService", "resize-2", "localhost:50052", ServiceStatus.ACTIVE),
        ]
        
        ai_instances = [
            ServiceInstance("AIDetectionService", "ai-1", "localhost:50061", ServiceStatus.ACTIVE, max_connections=50),
            ServiceInstance("AIDetectionService", "ai-2", "localhost:50062", ServiceStatus.ACTIVE, max_connections=50),
        ]
        
        filter_instances = [
            ServiceInstance("FilterService", "filter-1", "localhost:50071", ServiceStatus.ACTIVE),
        ]
        
        for instance in resize_instances + ai_instances + filter_instances:
            await self.service_registry.register_service(instance)
        
        # ãƒ˜ãƒ«ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹
        asyncio.create_task(self.service_registry.start_health_monitoring())
    
    async def execute_pipeline_step(
        self, 
        step: PipelineStep, 
        input_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """å¸¸é§gRPCã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ãŸã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ"""
        
        return await self.grpc_client.execute_step(
            service_name=step.service,
            method_name=step.method,
            input_data=input_data,
            timeout_ms=step.timeout_ms,
            max_retries=step.retry_count
        )
```

### 9.1.3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ãƒ»æœ€é©åŒ–

**ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†**:
```python
from dataclasses import dataclass
from typing import Dict, List
import time
import statistics

@dataclass
class PipelineMetrics:
    pipeline_id: str
    execution_id: str
    total_execution_time_ms: float
    step_metrics: Dict[str, Dict[str, float]]
    service_metrics: Dict[str, Dict[str, float]]
    resource_usage: Dict[str, float]

class MetricsCollector:
    def __init__(self):
        self.metrics_history: List[PipelineMetrics] = []
        
    async def collect_pipeline_metrics(
        self, 
        pipeline_id: str, 
        execution_context: Dict[str, Any]
    ) -> PipelineMetrics:
        """ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†"""
        
        metrics = PipelineMetrics(
            pipeline_id=pipeline_id,
            execution_id=execution_context["execution_id"],
            total_execution_time_ms=execution_context.get("execution_time_ms", 0),
            step_metrics={},
            service_metrics={},
            resource_usage={}
        )
        
        # ã‚¹ãƒ†ãƒƒãƒ—æ¯ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        for step_id, step_result in execution_context["step_results"].items():
            metrics.step_metrics[step_id] = {
                "execution_time_ms": step_result.get("execution_time_ms", 0),
                "input_size_bytes": step_result.get("input_size_bytes", 0),
                "output_size_bytes": step_result.get("output_size_bytes", 0),
                "retry_count": step_result.get("retry_count", 0)
            }
        
        # ã‚µãƒ¼ãƒ“ã‚¹æ¯ã®é›†è¨ˆãƒ¡ãƒˆãƒªã‚¯ã‚¹
        service_times = {}
        for step_id, step_result in execution_context["step_results"].items():
            service_name = step_result.get("service_name")
            if service_name:
                if service_name not in service_times:
                    service_times[service_name] = []
                service_times[service_name].append(
                    step_result.get("execution_time_ms", 0)
                )
        
        for service_name, times in service_times.items():
            metrics.service_metrics[service_name] = {
                "avg_execution_time_ms": statistics.mean(times),
                "max_execution_time_ms": max(times),
                "min_execution_time_ms": min(times),
                "total_calls": len(times)
            }
        
        self.metrics_history.append(metrics)
        return metrics
    
    def get_performance_insights(self, pipeline_id: str) -> Dict[str, Any]:
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æãƒ»æœ€é©åŒ–ææ¡ˆ"""
        
        pipeline_metrics = [m for m in self.metrics_history if m.pipeline_id == pipeline_id]
        
        if not pipeline_metrics:
            return {"error": "No metrics found for pipeline"}
        
        # å®Ÿè¡Œæ™‚é–“ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
        execution_times = [m.total_execution_time_ms for m in pipeline_metrics]
        
        insights = {
            "performance_summary": {
                "total_executions": len(pipeline_metrics),
                "avg_execution_time_ms": statistics.mean(execution_times),
                "95th_percentile_ms": statistics.quantiles(execution_times, n=20)[18] if len(execution_times) > 20 else max(execution_times),
                "improvement_trend": self.calculate_trend(execution_times)
            },
            "bottleneck_analysis": self.identify_bottlenecks(pipeline_metrics),
            "optimization_recommendations": self.generate_optimization_recommendations(pipeline_metrics)
        }
        
        return insights

# FastAPIçµ±åˆ
@app.get("/api/v1/pipelines/{pipeline_id}/metrics")
async def get_pipeline_metrics(pipeline_id: str):
    """ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹å–å¾—"""
    
    collector = MetricsCollector()
    insights = collector.get_performance_insights(pipeline_id)
    
    return {
        "pipeline_id": pipeline_id,
        "metrics": insights,
        "timestamp": time.time()
    }
```

ã“ã‚Œã‚‰ã®æ–°ã—ã„ç« ã«ã‚ˆã‚Šã€Tauriã‚¢ãƒ—ãƒªã‹ã‚‰Backend APIã¸ã®gRPCé€šä¿¡ã€å®šç¾©æ¸ˆã¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Ÿè¡Œã€ãŠã‚ˆã³å¸¸é§gRPCã‚µãƒ¼ãƒ“ã‚¹ã®ä½¿ç”¨ã«ã¤ã„ã¦åŒ…æ‹¬çš„ãªè¨­è¨ˆä»•æ§˜ãŒæä¾›ã•ã‚Œã¾ã™ã€‚